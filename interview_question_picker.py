# -*- coding: utf-8 -*-
"""Interview question picker

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M7vwFywFSvS4GSEU5V3UokH9vsMZXNnP

Modules installation
"""

!pip install pandas

!pip install fpdf

"""Sample dataset viewing"""

import pandas as pd
import random

# Parameters for the dataset
categories = ['Easy', 'Medium', 'Hard']
time_values = [5, 10, 15]
weight_values = [10, 20, 30, 40]

# Generating the first 5 sample rows
sample_data = []
for i in range(5):
    question = f"Sample question {i+1}: Describe a scenario relevant to category {random.choice(categories)}."
    category = random.choice(categories)
    time = random.choice(time_values)
    weight = random.choice(weight_values)
    sample_data.append({'Question': question, 'Category': category, 'Time (minutes)': time, 'Weight (marks)': weight})

# Creating a DataFrame
sample_df = pd.DataFrame(sample_data)
sample_df

"""This code is to create the dataset"""

import pandas as pd
import random

# Parameters
num_samples = 10000  # Total dataset size
questions_per_category = num_samples // 3  # Even distribution across categories
time_range = [5, 10, 15]  # Time in minutes, multiples of 5
marks_range = [10, 20, 30, 40]  # Marks in multiples of 5

# Generate dataset with specified constraints
data = []
for i in range(1, num_samples + 1):
    if i <= questions_per_category:
        category = 'Easy'
    elif i <= 2 * questions_per_category:
        category = 'Medium'
    else:
        category = 'Hard'

    time = random.choice(time_range)
    weight = random.choice(marks_range)
    text = f"This is a uniquely identifiable text snippet number {i}."
    data.append([f"Q{i:05d}", category, text, weight, time])

# Create the full dataset DataFrame
df = pd.DataFrame(data, columns=['ID', 'Category', 'Text', 'Weight', 'Time (minutes)'])

# Save the dataset to a CSV file
file_path = 'interview_questions_dataset.csv'
df.to_csv(file_path, index=False)

print(f"✅ Dataset successfully generated and saved as {file_path}")

"""This part downloads the dataset created by the above as a CSV file

"""

from google.colab import files

# Download the generated dataset
files.download('interview_questions_dataset.csv')

"""Upload files into colab"""

from google.colab import files
uploaded = files.upload()

"""Loads dataset into colab environment"""

# Load the dataset
file_path = '/content/interview_questions_dataset_2.csv'  #Path in Colab, modify if needed
df = pd.read_csv(file_path)

"""Main code - Selects the required questions as per given constraints - Exports selected questions as csv"""

import pandas as pd
import random

# Load the dataset
file_path = '/content/interview_questions_dataset_2.csv'  # Path in Colab, modify if needed
df = pd.read_csv(file_path)

# Parameters
time = int(input("Enter the required time in minutes: "))
weight = int(input("Enter the required weight in marks: "))

# Group by categories
easy_questions = df[df['Category'] == 'Easy']
medium_questions = df[df['Category'] == 'Medium']
hard_questions = df[df['Category'] == 'Hard']

# Function to select questions within constraints
def select_interview_questions(df_easy, df_medium, df_hard, time_min, time_max, weight_min, weight_max):
    selected_questions = []
    total_time = 0
    total_weight = 0

    # Limit random selection to a manageable number of questions
    num_questions = 10  # We will attempt to pick 10 questions in total, 3 from each category and some extra if needed

    # Select questions from each category
    easy_q = random.sample(df_easy.to_dict('records'), num_questions // 3)
    medium_q = random.sample(df_medium.to_dict('records'), num_questions // 3)
    hard_q = random.sample(df_hard.to_dict('records'), num_questions // 3)

    # Combine all selected questions
    all_selected = easy_q + medium_q + hard_q

    # Shuffle the selected questions to avoid any bias in the order
    random.shuffle(all_selected)

    # Add selected questions while checking time and weight constraints
    for question in all_selected:
        if total_time + question['Time (minutes)'] <= time_max and total_weight + question['Weight'] <= weight_max:
            selected_questions.append(question)
            total_time += question['Time (minutes)']
            total_weight += question['Weight']

        # Break loop if constraints are met
        if time_min <= total_time <= time_max and weight_min <= total_weight <= weight_max:
            break

    return selected_questions, total_time, total_weight

# Run the selection
selected_questions, final_time, final_weight = select_interview_questions(easy_questions, medium_questions, hard_questions, time_min, time_max, weight_min, weight_max)

# Display results
print(f"✅ Selected {len(selected_questions)} questions for the interview.")
print(f"⏱️ Total Time: {final_time} minutes")
print(f"🏋️ Total Weight: {final_weight} marks")

# Convert the selected questions back to DataFrame and save
selected_df = pd.DataFrame(selected_questions)
selected_df.to_csv('selected_interview_questions.csv', index=False)

# Allow download of the selected questions in Colab
from google.colab import files
files.download('selected_interview_questions.csv')

"""Code to generate data set with uniform distribution"""

import pandas as pd
import random

# Parameters
num_samples = 10000  # Total dataset size
questions_per_category = num_samples // 3  # Even distribution across categories

# Time and Marks ranges (we'll use uniform distribution within these ranges)
time_min = 5  # Minimum time
time_max = 15  # Maximum time
marks_min = 10  # Minimum marks
marks_max = 50  # Maximum marks
time = int(input("Enter the required time in minutes:"))
marks = int(input("Enter the required marks:"))

# Generate dataset with specified constraints
data = []
for i in range(1, num_samples + 1):
    if i <= questions_per_category:
        category = 'Easy'
    elif i <= 2 * questions_per_category:
        category = 'Medium'
    else:
        category = 'Hard'

    # Generate time and weight using uniform distribution and round to nearest multiple of 5
    time = round(random.uniform(time_min, time_max) / 5) * 5
    weight = round(random.uniform(marks_min, marks_max) / 5) * 5

    text = f"This is a uniquely identifiable text snippet number {i}."
    data.append([f"Q{i:05d}", category, text, weight, time])

# Create the full dataset DataFrame
df = pd.DataFrame(data, columns=['ID', 'Category', 'Text', 'Weight', 'Time (minutes)'])

# Save the dataset to a CSV file
file_path = 'interview_questions_dataset_uniform.csv'
df.to_csv(file_path, index=False)

print(f"✅ Dataset successfully generated and saved as {file_path}")

from google.colab import files

# Download the generated dataset
files.download('interview_questions_dataset_uniform.csv')

"""Selects the questions randomly based on mark requirements and downloads as CSV"""

import pandas as pd
import random

# Load the dataset
file_path = '/content/interview_questions_dataset_2.csv'  # Path in Colab, modify if needed
df = pd.read_csv(file_path)

# Parameters
time_min = int(input("Enter the required minimum time in minutes: "))
time_max = int(input("Enter the required maximum time in minutes: "))
marks_min = int(input("Enter the required minimum weight (marks): "))
marks_max = int(input("Enter the required maximum weight (marks): "))

# Group by categories
easy_questions = df[df['Category'] == 'Easy']
medium_questions = df[df['Category'] == 'Medium']
hard_questions = df[df['Category'] == 'Hard']

# Function to select questions within constraints
def select_interview_questions(df_easy, df_medium, df_hard, time_min, time_max, marks_min, marks_max):
    selected_questions = []
    total_time = 0
    total_marks = 0

    # Randomly select questions from each category
    # Add random sample logic for more flexible question count
    num_easy = random.randint(1, len(df_easy))  # Randomly pick from easy
    num_medium = random.randint(1, len(df_medium))  # Randomly pick from medium
    num_hard = random.randint(1, len(df_hard))  # Randomly pick from hard

    easy_q = random.sample(df_easy.to_dict('records'), num_easy)
    medium_q = random.sample(df_medium.to_dict('records'), num_medium)
    hard_q = random.sample(df_hard.to_dict('records'), num_hard)

    # Combine all selected questions
    all_selected = easy_q + medium_q + hard_q

    # Shuffle the selected questions to avoid any bias in the order
    random.shuffle(all_selected)

    # Add selected questions while checking time and weight constraints
    for question in all_selected:
        if total_time + question['Time (minutes)'] <= time_max and total_marks + question['Weight'] <= marks_max:
            selected_questions.append(question)
            total_time += question['Time (minutes)']
            total_marks += question['Weight']

        # Check if the constraints are met
        if time_min <= total_time <= time_max and marks_min <= total_marks <= marks_max:
            break

    return selected_questions, total_time, total_marks

# Run the selection
selected_questions, final_time, final_marks = select_interview_questions(
    easy_questions, medium_questions, hard_questions, time_min, time_max, marks_min, marks_max)

# Display results
print(f"✅ Selected {len(selected_questions)} questions for the interview.")
print(f"⏱️ Total Time: {final_time} minutes")
print(f"🏋️ Total Marks: {final_marks} marks")

# Convert the selected questions back to DataFrame and save
selected_df = pd.DataFrame(selected_questions)
selected_df.to_csv('selected_interview_questions.csv', index=False)

# Allow download of the selected questions in Colab
from google.colab import files
files.download('selected_interview_questions.csv')

"""Selects questions and downloads as a PDF - output slightly off with marks and time not distributing properly"""

import pandas as pd
import random
from fpdf import FPDF  # Importing fpdf to create PDFs

# Load the dataset
file_path = '/content/interview_questions_dataset_2.csv'  # Path in Colab, modify if needed
df = pd.read_csv(file_path)

# Parameters
time_min = int(input("Enter the required minimum time in minutes: "))
time_max = int(input("Enter the required maximum time in minutes: "))
marks_min = int(input("Enter the required minimum weight (marks): "))
marks_max = int(input("Enter the required maximum weight (marks): "))

# Group by categories
easy_questions = df[df['Category'] == 'Easy']
medium_questions = df[df['Category'] == 'Medium']
hard_questions = df[df['Category'] == 'Hard']

# Function to select questions efficiently based on the time and marks constraints
def select_interview_questions_uniform(df_easy, df_medium, df_hard, time_min, time_max, marks_min, marks_max):
    selected_questions = []
    total_time = 0
    total_marks = 0

    # Function to select questions from a given category within time and marks constraints
    def select_category_questions(df_category, category_time_limit, category_marks_limit):
        selected_category_q = []
        total_category_time = 0
        total_category_marks = 0

        # Sort by time and marks to pick the most fitting questions
        df_category = df_category.sort_values(by=['Time (minutes)', 'Weight'], ascending=True)

        for index, question in df_category.iterrows():
            if total_category_time + question['Time (minutes)'] <= category_time_limit and total_category_marks + question['Weight'] <= category_marks_limit:
                selected_category_q.append(question)
                total_category_time += question['Time (minutes)']
                total_category_marks += question['Weight']

        return selected_category_q

    # Select questions from each category using the function above
    easy_q = select_category_questions(df_easy.copy(), (time_max - total_time) // 3, (marks_max - total_marks) // 3)
    medium_q = select_category_questions(df_medium.copy(), (time_max - total_time) // 3, (marks_max - total_marks) // 3)
    hard_q = select_category_questions(df_hard.copy(), (time_max - total_time) // 3, (marks_max - total_marks) // 3)

    # Combine all selected questions
    selected_questions = easy_q + medium_q + hard_q

    # Check if time and marks constraints are met
    total_time = sum([q['Time (minutes)'] for q in selected_questions])
    total_marks = sum([q['Weight'] for q in selected_questions])

    # If not enough questions selected, try to fill the remaining time and marks
    if total_time < time_min or total_marks < marks_min:
        remaining_easy_q = select_category_questions(df_easy, (time_max - total_time), (marks_max - total_marks))
        remaining_medium_q = select_category_questions(df_medium, (time_max - total_time), (marks_max - total_marks))
        remaining_hard_q = select_category_questions(df_hard, (time_max - total_time), (marks_max - total_marks))

        # Add additional questions to meet time and marks requirements
        selected_questions.extend(remaining_easy_q + remaining_medium_q + remaining_hard_q)

    # Final check to ensure constraints are met
    total_time = sum([q['Time (minutes)'] for q in selected_questions])
    total_marks = sum([q['Weight'] for q in selected_questions])

    return selected_questions, total_time, total_marks

# Run the selection with uniform distribution
selected_questions, final_time, final_marks = select_interview_questions_uniform(
    easy_questions, medium_questions, hard_questions, time_min, time_max, marks_min, marks_max)

# Display results
print(f"✅ Selected {len(selected_questions)} questions for the interview.")
print(f"⏱️ Total Time: {final_time} minutes")
print(f"🏋️ Total Marks: {final_marks} marks")

# Create a PDF to save the selected questions
pdf = FPDF()
pdf.set_auto_page_break(auto=True, margin=15)
pdf.add_page()

# Set title and font for the PDF
pdf.set_font('Arial', 'B', 16)
pdf.cell(200, 10, txt="Selected Interview Questions", ln=True, align='C')

# Add each selected question to the PDF
pdf.ln(10)  # Line break
pdf.set_font('Arial', '', 12)

for i, question in enumerate(selected_questions, start=1):
    pdf.cell(200, 10, txt=f"Q{i}: {question['Text']} - Marks: {question['Weight']} - Time: {question['Time (minutes)']} minutes", ln=True)

# Save the PDF
pdf_output_path = "/content/selected_interview_questions.pdf"
pdf.output(pdf_output_path)

# Allow download of the selected questions as PDF in Colab
from google.colab import files
files.download(pdf_output_path)

"""Perfect output"""

import pandas as pd
import random
from fpdf import FPDF

# Load the dataset
file_path = '/content/interview_questions_dataset_2.csv'  # Path in Colab, modify if needed
df = pd.read_csv(file_path)

# Parameters
marks_min = int(input("Enter the required minimum weight (marks): "))
marks_max = int(input("Enter the required maximum weight (marks): "))

# Group by categories
easy_questions = df[df['Category'] == 'Easy']
medium_questions = df[df['Category'] == 'Medium']
hard_questions = df[df['Category'] == 'Hard']

# Function to select questions based purely on marks and distribute evenly across categories
def select_interview_questions_by_marks(df_easy, df_medium, df_hard, marks_min, marks_max):
    selected_questions = []
    total_marks = 0

    # Function to select questions from a given category within marks constraints
    def select_category_questions(df_category, category_marks_limit):
        selected_category_q = []
        total_category_marks = 0

        # Randomly shuffle and select questions from the category until the limit is reached
        df_category = df_category.sample(frac=1).reset_index(drop=True)  # Shuffle questions in the category

        for idx, question in df_category.iterrows():
            if total_category_marks + question['Weight'] <= category_marks_limit:
                selected_category_q.append(question)
                total_category_marks += question['Weight']

        return selected_category_q

    # Try selecting questions for each category to meet the marks requirement
    easy_q = select_category_questions(df_easy.copy(), marks_max // 3)  # Marks distributed evenly
    medium_q = select_category_questions(df_medium.copy(), marks_max // 3)
    hard_q = select_category_questions(df_hard.copy(), marks_max // 3)

    # Combine all selected questions
    selected_questions = easy_q + medium_q + hard_q

    # Shuffle to avoid any order bias
    random.shuffle(selected_questions)

    # Final check if marks constraints are met
    total_marks = sum([q['Weight'] for q in selected_questions])

    # If final marks constraints are not met, select additional questions from any category
    if total_marks < marks_min:
        remaining_questions = easy_q + medium_q + hard_q  # Remaining pool of questions
        # Check if we still have questions left to pick
        while total_marks < marks_min and remaining_questions:
            # Randomly select from the remaining questions
            question = random.choice(remaining_questions)
            selected_questions.append(question)
            total_marks += question['Weight']
            remaining_questions.remove(question)

    # If total_marks exceed the max limit, truncate the selected questions list
    if total_marks > marks_max:
        selected_questions = selected_questions[:(marks_max // selected_questions[0]['Weight'])]

    return selected_questions, total_marks

# Run the selection based on marks
selected_questions, final_marks = select_interview_questions_by_marks(
    easy_questions, medium_questions, hard_questions, marks_min, marks_max)

# Display results
print(f"✅ Selected {len(selected_questions)} questions for the interview.")
print(f"🏋️ Total Marks: {final_marks} marks")

# Check if questions are selected, otherwise indicate that no valid selection was made
if not selected_questions:
    print("❌ No questions selected. The constraints may be too strict for the available questions.")
else:
    # Convert the selected questions back to DataFrame and save
    selected_df = pd.DataFrame(selected_questions)

   # Convert the DataFrame to PDF
pdf = FPDF()
pdf.set_auto_page_break(auto=True, margin=15)
pdf.add_page()
pdf.set_font("Arial", size=12)

# Add a title
pdf.cell(200, 10, txt="Selected Interview Questions", ln=True, align='C')

# Add questions to PDF with difficulty level
for index, row in selected_df.iterrows():
    question_text = f"Q{row['ID']}: {row['Text']} - Difficulty: {row['Category']} - Marks: {row['Weight']} - Time: {row['Time (minutes)']} minutes"
    pdf.multi_cell(0, 10, question_text)

# Save the PDF to a file
pdf_output_path = "/content/selected_interview_questions.pdf"
pdf.output(pdf_output_path)

# Allow download of the selected questions in Colab
from google.colab import files
files.download(pdf_output_path)

"""Code for the same problem in VS code - with two mark input parameters"""

import pandas as pd
import random
from fpdf import FPDF
import os

# -----------------------------
# 📂 Load the Dataset
# -----------------------------
file_path = r'C:\Users\jothishreyaa_j\Downloads\P1 - Interview question picker\interview_questions_dataset_2.csv'  # Local file path

# Check if the file exists
if not os.path.exists(file_path):
    raise FileNotFoundError(f"The file '{file_path}' was not found. Please ensure it's in the script directory.")

df = pd.read_csv(file_path)

# -----------------------------
# ⚙️ Parameters
# -----------------------------
marks_min = int(input("Enter the required minimum weight (marks): "))
marks_max = int(input("Enter the required maximum weight (marks): "))

# -----------------------------
# 🗂️ Group by Categories
# -----------------------------
easy_questions = df[df['Category'] == 'Easy']
medium_questions = df[df['Category'] == 'Medium']
hard_questions = df[df['Category'] == 'Hard']

# -----------------------------
# 🎯 Select Questions by Marks
# -----------------------------
def select_interview_questions_by_marks(df_easy, df_medium, df_hard, marks_min, marks_max):
    selected_questions = []
    total_marks = 0

    def select_category_questions(df_category, category_marks_limit):
        selected_category_q = []
        total_category_marks = 0
        df_category = df_category.sample(frac=1).reset_index(drop=True)  # Shuffle questions

        for idx, question in df_category.iterrows():
            if total_category_marks + question['Weight'] <= category_marks_limit:
                selected_category_q.append(question)
                total_category_marks += question['Weight']

        return selected_category_q

    # Select evenly from each category
    easy_q = select_category_questions(df_easy.copy(), marks_max // 3)
    medium_q = select_category_questions(df_medium.copy(), marks_max // 3)
    hard_q = select_category_questions(df_hard.copy(), marks_max // 3)

    selected_questions = easy_q + medium_q + hard_q
    random.shuffle(selected_questions)

    total_marks = sum([q['Weight'] for q in selected_questions])

    if total_marks < marks_min:
        remaining_questions = easy_q + medium_q + hard_q
        while total_marks < marks_min and remaining_questions:
            question = random.choice(remaining_questions)
            selected_questions.append(question)
            total_marks += question['Weight']
            remaining_questions.remove(question)

    if total_marks > marks_max:
        selected_questions = selected_questions[:(marks_max // selected_questions[0]['Weight'])]

    return selected_questions, total_marks

# -----------------------------
# 📊 Run Selection
# -----------------------------
selected_questions, final_marks = select_interview_questions_by_marks(
    easy_questions, medium_questions, hard_questions, marks_min, marks_max)

print(f"✅ Selected {len(selected_questions)} questions for the interview.")
print(f"🏋️ Total Marks: {final_marks} marks")

if not selected_questions:
    print("❌ No questions selected. The constraints may be too strict for the available questions.")
else:
    selected_df = pd.DataFrame(selected_questions)

# -----------------------------
# 📄 Generate PDF
# -----------------------------
pdf = FPDF()
pdf.set_auto_page_break(auto=True, margin=15)
pdf.add_page()
pdf.set_font("Arial", size=12)
pdf.cell(200, 10, txt="Selected Interview Questions", ln=True, align='C')

for index, row in selected_df.iterrows():
    question_text = f"Q{row['ID']}: {row['Text']} - Difficulty: {row['Category']} - Marks: {row['Weight']} - Time: {row['Time (minutes)']} minutes"
    pdf.multi_cell(0, 10, question_text)

# Save PDF locally
pdf_output_path = 'VS_selected_interview_questions1.pdf'
pdf.output(pdf_output_path)
print(f"📁 PDF saved successfully: {pdf_output_path}")

"""VS code for the same problem - one mark parameter"""

#The time constaint slightly exceeds the expected range if given maximum marks aka 100
import pandas as pd
import random
from fpdf import FPDF
import os

# -----------------------------
# 📂 Load the Dataset
# -----------------------------
file_path = r'C:\Users\jothishreyaa_j\Downloads\P1 - Interview question picker\interview_questions_dataset_2.csv'  # Local file path

# Check if the file exists
if not os.path.exists(file_path):
    raise FileNotFoundError(f"The file '{file_path}' was not found. Please ensure it's in the script directory.")

df = pd.read_csv(file_path)

# -----------------------------
# ⚙️ Parameters
# -----------------------------
marks = int(input("Enter the required weight (marks): "))

# -----------------------------
# 🗂️ Group by Categories
# -----------------------------
easy_questions = df[df['Category'] == 'Easy']
medium_questions = df[df['Category'] == 'Medium']
hard_questions = df[df['Category'] == 'Hard']

# -----------------------------
# 🎯 Select Questions by Marks
# -----------------------------
def select_interview_questions_by_marks(df_easy, df_medium, df_hard, marks):
    selected_questions = []
    total_marks = 0

    def select_category_questions(df_category, category_marks_limit):
        selected_category_q = []
        total_category_marks = 0
        df_category = df_category.sample(frac=1).reset_index(drop=True)  # Shuffle questions

        for idx, question in df_category.iterrows():
            if total_category_marks + question['Weight'] <= category_marks_limit:
                selected_category_q.append(question)
                total_category_marks += question['Weight']

        return selected_category_q

    # Select evenly from each category
    easy_q = select_category_questions(df_easy.copy(), marks // 3)
    medium_q = select_category_questions(df_medium.copy(), marks // 3)
    hard_q = select_category_questions(df_hard.copy(), marks // 3)

    selected_questions = easy_q + medium_q + hard_q
    random.shuffle(selected_questions)

    total_marks = sum([q['Weight'] for q in selected_questions])

    if total_marks < marks:
        remaining_questions = easy_q + medium_q + hard_q
        while total_marks < marks and remaining_questions:
            question = random.choice(remaining_questions)
            selected_questions.append(question)
            total_marks += question['Weight']
            # Remove by the index to avoid ambiguity
            remaining_questions = [q for q in remaining_questions if not q.equals(question)]

    if total_marks > marks:
        selected_questions = selected_questions[:(marks // selected_questions[0]['Weight'])]

    return selected_questions, total_marks

# -----------------------------
# 📊 Run Selection
# -----------------------------
selected_questions, final_marks = select_interview_questions_by_marks(
    easy_questions, medium_questions, hard_questions, marks)

print(f"✅ Selected {len(selected_questions)} questions for the interview.")
print(f"🏋️ Total Marks: {final_marks} marks")

# Check if questions are selected
if not selected_questions:
    print("❌ No questions selected. The constraints may be too strict for the available questions.")
    exit()
else:
    # Convert the list of selected questions to a DataFrame
    selected_df = pd.DataFrame.from_records(selected_questions)

# -----------------------------
# 📄 Generate PDF
# -----------------------------
pdf = FPDF()
pdf.set_auto_page_break(auto=True, margin=15)
pdf.add_page()
pdf.set_font("Arial", size=12)
pdf.cell(200, 10, txt="Selected Interview Questions", ln=True, align='C')

for index, row in selected_df.iterrows():
    question_text = f"Q{row['ID']}: {row['Text']} - Difficulty: {row['Category']} - Marks: {row['Weight']} - Time: {row['Time (minutes)']} minutes"
    pdf.multi_cell(0, 10, question_text)

# Save PDF locally
pdf_output_path = 'VS_selected_interview_questions1.pdf'
pdf.output(pdf_output_path)
print(f"📁 PDF saved successfully: {pdf_output_path}")